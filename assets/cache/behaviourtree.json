{"id":"behaviourtree","deps":["class","abstract/behaviour-tree"],"as":{},"info":"\n\nbehaviour tree\n\n有两种基本状态:\n\n- @SUCCESS\n- @FAILED\n\n为了游戏不阻塞而设计的:\n\n- @RUNNING\n\n了解概念可以参考 #abstract/behaviour-tree\n\n","extern":[{"id":"SUCCESS","info":"\n\nSUCCESS = @BehaviourNodeStatus\n\n```lua\nSUCCESS = \"SUCCESS\"\n```\n\n"},{"id":"FAILED","info":"\n\nFAILED = @BehaviourNodeStatus\n\n```lua\nFAILED = \"FAILED\"\n```\n\n"},{"id":"READY","info":"\n\nREADY = @BehaviourNodeStatus\n\n```lua\nREADY = \"READY\"\n```\n\n"},{"id":"RUNNING","info":"\n\nRUNNING = @BehaviourNodeStatus\n\n```lua\nRUNNING = \"RUNNING\"\n```\n\n"},{"id":"BT","info":"\n\nBT = inst, root\n\nbehaviour tree\n\n"},{"id":"BT-ForceUpdate","info":"\n\n() => ()\n\n实际上, 设置内部状态为 forceupdate = true\n\n"},{"id":"BT-Update","info":"\n\n() => ()\n\n行为树更新状态\n\n相当于: g_player->btexec()是在游戏的更新函数（update 或 tick）里，需要每帧调用(https://www.behaviac.com/language/zh/concepts/)\n\n"},{"id":"BT-Reset","info":"\n\n() => ()\n\n重置 @BT\n\n委托 root @BehaviourNode-Reset\n\n"},{"id":"BT-Stop","info":"\n\n() => ()\n\n委托 root @BehaviourNode-Stop\n\n"},{"id":"BT-GetSleepTime","info":"\n\n() => Number\n\n委托 root @BehaviourNode-GetSleepTime\n\n"},{"id":"BehaviourNode","info":"\n\nBehaviourNode = name: string, children: [ @BehaviourNode ]\n\nBehaviourNode:\n\n- name\n- children\n- status: @BehaviourNodeStatus = @READY\n- lastresult: @BehaviourNodeStatus = @READY\n- parent: @BehaviourNode\n- id: Number, 用于分配 imgui\n\n"},{"id":"BehaviourNode-DoToParents","info":"\n\nfn => ()\n\n- fn: (node: @BehaviourNode => ())\n\n对所有的 parents 执行 fn\n\n"},{"id":"BehaviourNode-Sleep","info":"\n\nt => ()\n\n实际上是修改更新的时间 self.nextupdatetime\n\n"},{"id":"BehaviourNode-GetSleepTime","info":"\n\n() => ()\n\n正在执行的 @ActionNode 才有 sleep time\n\n"},{"id":"BehaviourNode-GetTreeSleepTime","info":"\n\n() => ()\n\n实际上就是计算最底层所有子节点中最大的 sleep time\n\n"},{"id":"BehaviourNode-Visit","info":"\n\n() => ()\n\n将当前节点 status 设为 FAILED\n\n"},{"id":"BehaviourNode-SaveStatus","info":"\n\n() => ()\n\n将自己和所有子节点的状态保留进入 lastresult\n\n"},{"id":"BehaviourNode-Step","info":"\n\n() => ()\n\n- not @RUNNING, 则重置节点状态\n- @RUNNING, 则调用子节点 @BehaviourNode-Step 进行递归\n\n"},{"id":"BehaviourNode-Reset","info":"\n\n() => ()\n\n将当前节点和所有子节点设置为 READY\n\n"},{"id":"BehaviourNode-Stop","info":"\n\n() => ()\n\n停止当前及其所有子节点\n\n"},{"id":"DecoratorNode","info":"\n\nDecoratorNode = (name = \"Decorator\", child: @BehaviourNode) extends @BehaviourNode\n\n"},{"id":"ConditionNode","info":"\n\nConditionNode = (fn, name = \"Condition\") extends @BehaviourNode\n\nclass:\n\n- fn: () => (), 挂载条件\n\n"},{"id":"ConditionNode-Visit","info":"\n\n() => Boolean\n\nself.fn() 成功则返回 @SUCCESS, 否则返回 @FAILED\n\n"},{"id":"MultiConditionNode","info":"\n\nMultiConditionNode = (start, continue, name = \"Condition\") extends @BehaviourNode\n\n- start\n- continue\n\n"},{"id":"MultiConditionNode-Visit","info":"\n\n() => ()\n\n"},{"id":"ConditionWaitNode","info":"\n\nConditionWaitNode = (fn, name = \"Wait\") extends @BehaviourNode\n\n- fn: () => Boolean, 挂载条件\n\n"},{"id":"ConditionWaitNode-Visit","info":"\n\n() => ()\n\nself.fn() 成功则返回 @SUCCESS, 否则返回 @RUNNING\n\n"},{"id":"ActionNode","info":"\n\nActionNode = (action, name = \"ActionNode\") extends @BehaviourNode\n\n- action: 挂载动作\n\n"},{"id":"ActionNode-Visit","info":"\n\n执行完动作返回 @SUCCESS\n\n"},{"id":"WaitNode","info":"\n\nWaitNode = (time, time) extends @BehaviourNode\n\n- self.name = \"Wait\"\n- self.wait_time = time\n\n"},{"id":"WaitNode-Visit","info":"\n\n() => ()\n\n- not @RUNNING, 则变成@RUNNING, 并且设置 self.wake_time\n- @RUNNING, self.wake_time 超过当前时间则返回成功, 没有则 @BehaviourNode-Sleep\n\n"},{"id":"SequenceNode","info":"\n\nSequenceNode = (children: [ @BehaviourNode ]) extends @BehaviourNode\n\n- self.name = \"Sequence\"\n- self.idx = 1 : 内部指针\n\n相当于 and 容器\n\n"},{"id":"SequenceNode-Reset","info":"\n\n() => ()\n\n1. @BehaviourNode-Reset\n2. 内部指针归位\n\n"},{"id":"SequenceNode-Visit","info":"\n\n() => ()\n\n依次遍历 children, 实现 and 逻辑\n\n遇到 @FAILED, 则返回 @FAILED\n\n遇到 @RUNNING, 则返回 @RUNNING, 这是为了不阻塞\n\n"},{"id":"SelectorNode","info":"\n\nSelectorNode = (children: [ @BehaviourNode ]) extends @BehaviourNode\n\n- self.name = \"Selector\"\n- self.idx = 1 : 内部指针\n\n"},{"id":"SelectorNode-Reset","info":"\n\n() => ()\n\n同 @SequenceNode-Reset\n\n1. @BehaviourNode-Reset\n2. 内部指针归位\n\n实现 or 逻辑\n\n"},{"id":"SelectorNode-Visit","info":"\n\n() => ()\n\n依次遍历 children, 实现 or 逻辑\n\n遇到 @SUCCESS, 则返回 @SUCCESS\n\n遇到 @RUNNING, 则返回 @RUNNING, 这是为了不阻塞\n\n"},{"id":"NotDecorator","info":"\n\nNotDecorator = (child: @BehaviourNode) extends @DecoratorNode\n\n- self.name = \"Not\"\n\n实现 not 逻辑\n\n"},{"id":"NotDecorator-Visit","info":"\n\n() => ()\n\n将 @SUCCESS, @FAILED 取反, 其他委托返回\n\n"},{"id":"FailIfRunningDecorator","info":"\n\nFailIfRunningDecorator = (child: @BehaviourNode) extends @DecoratorNode\n\n- self.name = \"FailIfRunning\"\n\n@RUNNING, 返回 @FAILED\n\n"},{"id":"FailIfRunningDecorator-Visit","info":"\n\n() => ()\n\n@RUNNING, 返回 @FAILED, 其他委托返回\n\n"},{"id":"LoopNode","info":"\n\nLoopNode = (children: [ @BehaviourNode ], maxreps) extends @BehaviourNode\n\n- self.name = \"Sequence\"\n\n相当于将 @SequenceNode 重复 maxreps 次\n\n"},{"id":"LoopNode-Reset","info":"\n\n() => ()\n\nreset\n\n"},{"id":"LoopNode-Visit","info":"\n\n() => ()\n\n每次 visit 只会执行一次, 查过 maxreps 则返回 @SUCCESS\n\n"},{"id":"RandomNode","info":"\n\nRandomNode = (children: [ @BehaviourNode ]) extends @BehaviourNode\n\n- self.name = \"Random\"\n\n随机选择 @SUCCESS or @RUNNING 的子节点\n\n"},{"id":"RandomNode-Reset","info":"\n\n() => () override\n\n"},{"id":"RandomNode-Visit","info":"\n\n() => ()\n\n在 READY 的时候随机选择一个子节点, 失败则选择下一个, 直到 @SUCCESS or @RUNNING. 否则, 返回 @FAILED\n\n"},{"id":"PriorityNode","info":"\n\nPriorityNode = (children: [ @BehaviourNode ], period = 1, noscatter: Boolean) extends @BehaviourNode\n\n- period: 检测间隔\n- self.lasttime: 上次时间, 随机初始化\n\n一般作为根节点, 也可以作为 @SequenceNode 使用. 可以设置独立的检测时间间隔, 但不可以高于根节点的间隔, 否则根节点会先刷新\n\n"},{"id":"PriorityNode-GetSleepTime","info":"\n\n() => Number\n\nself.lasttime + self.period - GetTime()\n\n"},{"id":"PriorityNode-Reset","info":"\n\n() => () override\n\n"},{"id":"PriorityNode-Visit","info":"\n\n() => ()\n\n优先级节点的行为, 记录节点上次访问时间, 判断是否需要重新评估子节点等操作.如果所有子节点都执行失败, 则该节点状态为 FAILED\n\n"},{"id":"ParallelNode","info":"\n\nParallelNode = (children: [ @BehaviourNode ], name = \"Parallel\") extends @BehaviourNode\n\n"},{"id":"ParallelNode-Step","info":"\n\n() => ()\n\n- not @RUNNING, 则 Reset\n- @RUNNING, 将 @SUCCESS 的 @ConditionNode 进行 Reset\n\n"},{"id":"ParallelNode-Visit","info":"\n\n() => ()\n\nTODO\n\n"},{"id":"ParallelNodeAny","info":"\n\nParallelNodeAny = (children: [ @BehaviourNode ], name = \"Parallel(Any)\") extends @ParallelNode\n\n- self.stoponanycomplete = true\n\n"},{"id":"EventNode","info":"\n\nEventNode = (inst, event, child: @BehaviourNode, priority: Number) extends @BehaviourNode\n\n- self.name = \"Event(${event})\"\n- self.eventfn: (inst, data) => self:OnEvent(data)\n- inst 监听 event\n\n"},{"id":"EventNode-OnStop","info":"\n\n() => ()\n\n移除监听\n\n"},{"id":"EventNode-OnEvent","info":"\n\n(data) => ()\n\n1. 中断子节点\n2. 强制更新 @Brain\n3. 唤醒父节点 @PriorityNode\n\n"},{"id":"EventNode-Step","info":"\n\n() => () override\n\n"},{"id":"EventNode-Reset","info":"\n\n() => () override\n\n"},{"id":"EventNode-Visit","info":"\n\n() => ()\n\n执行子节点\n\n"},{"id":"WhileNode","info":"\n\ncond: fn, name, node: @BehaviourNode => @ParallelNode ( @ConditionNode, @BehaviourNode )\n\n"},{"id":"IfNode","info":"\n\ncond: fn, name, node: @BehaviourNode => @SequenceNode ( @ConditionNode, @BehaviourNode )\n\n"},{"id":"IfThenDoWhileNode","info":"\n\nifcond, whilecond, name, node: @BehaviourNode => @ParallelNode ( @MultiConditionNode, @BehaviourNode )\n\n"},{"id":"LatchNode","info":"\n\nLatchNode = (inst, latchduration, child: @BehaviourNode) extends @BehaviourNode\n\n- self.name = \"Latch(${latchduration})\"\n\n"},{"id":"LatchNode-Visit","info":"\n\nTODO\n\n"}],"local":[{"id":"profilewrapvisit","info":"\n\nnode: @BehaviourNode => ()\n\ndecorate 所有 node 的 @BehaviourNode-Visit\n\n"}]}